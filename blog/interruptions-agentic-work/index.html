<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Luke Osborne's personal website" name=description><title>Interruptions Get More Expensive with Agentic Work | Luke Osborne</title><script>(function(){try{function a(d){if(d==="amber")return "yellow";return d}function b(){var d=new Date().getMonth();if(d===11||d===0||d===1)return "blue";if(d>=2&&d<=4)return "green";if(d>=5&&d<=7)return "yellow";return "red"}var c=a(localStorage.getItem("terminal-theme"));if(!c)c=b();if(c)document.documentElement.setAttribute("data-theme",c)}catch(d){}})()</script><link href="https://lukoktonos.com/favicon.svg?h=ab4abb9c75fd6a26fc45" rel=icon type=image/svg+xml><link href="https://lukoktonos.com/favicon-32.png?h=6b732b0ca73ff769a2c7" rel=icon sizes=32x32 type=image/png><link href="https://lukoktonos.com/favicon-16.png?h=9ffbfdbfe2222df52136" rel=icon sizes=16x16 type=image/png><link href="https://lukoktonos.com/apple-touch-icon.png?h=cefaff518b24479ddd7c" rel=apple-touch-icon sizes=180x180><link title="Luke Osborne Blog Feed" href=https://lukoktonos.com/blog/atom.xml rel=alternate type=application/atom+xml><link href="https://lukoktonos.com/site.css?h=cbbd905d725b9d1f09a9" rel=stylesheet><body><div class=screen-noise></div><main class=shell><header class=shell-header><a class=brand href=https://lukoktonos.com/>lukoktonos.com</a><nav><a href=https://lukoktonos.com/blog/>blog</a><a href=https://lukoktonos.com/blog/atom.xml>feed</a><a href=https://github.com/lukoktonos>github</a></nav></header><section class=terminal><article><h1>Interruptions Get More Expensive with Agentic Work</h1><p class=post-date>2026-02-26<p>There is nothing new under the sun here: interruptions have always been expensive, and the tension between management cadence and developer focus has always been real. If you are deep in a problem, a ping from your manager is usually not a thirty-second detour. It is context eviction followed by a slow rebuild.<p>The new twist is not that interruptions hurt. The new twist is what gets interrupted.<p>AI helps with recovery. You can externalize state into prompts, notes, diffs, and transcripts, then reload that state later. That part is genuinely better than it used to be.<p>At the same time, many of us now run several active streams: implementation in one pane, exploration in another, tests or cleanup in a third. These streams are related. They share assumptions, converge on the same interfaces, and invalidate each other when decisions change. So an interruption often preempts a coordinated set of streams, not a single linear task.<p>Another analogy I keep coming back to: coding with agents feels a bit like playing StarCraft. You are managing multiple fronts, queues, and timing windows at once. If you interrupt someone in the middle of that, it rarely goes well. The interruption cost is not just "what was I doing?" It is "which things were synchronized, and what just drifted?"<p>An OS analogy is useful here as well. A context switch is the system pausing one unit of work, saving enough state to resume it later, selecting another runnable unit, restoring state, and continuing execution.<p>Switching between threads in one process is often cheaper because much of the memory context is shared. Switching between separate processes is typically heavier because process-level memory context changes, which is rougher on locality and cache warmth. Forked process trees are heavier still: parent and workers can be paused at different points, and resume now includes re-coordination, not just restart.<p>That is close to what multi-stream agentic work feels like in practice. The immediate interruption might be one ping, but the recovery cost includes rehydrating each stream and then reconciling them.<p>You can model it roughly as:<pre class=language-text data-lang=text><code class=language-text data-lang=text>interruption_cost
  ~= base_restore
   + stream_count * per_stream_restore
   + interaction_points * reconciliation_cost
   + (stream_count * interaction_points) * coordination_penalty
</code></pre><p>The last term is the important one: it captures coupling overhead. More streams and more interaction points multiply each other, which is why interruption cost can grow faster than linearly.<p>For developers, the play is to reduce interaction points and offload state aggressively: short handoff notes, explicit decision records, cleaner boundaries between active streams.<p>For managers, this is a reminder that existing best practices matter even more now. If engineers are running multiple agentic streams, ad hoc preemption is expensive. Protected focus blocks, batched asks, and a culture where pings are not assumed to require immediate response all pay off.<p>AI did not change the basic physics of attention. It increased how much parallel work we can run, which makes interruption discipline more important than ever.</article></section><footer class=shell-footer><span>Â© 2026 Luke Osborne</span><div class=footer-controls><div aria-label="Terminal color selector" class=theme-buttons><button class="theme-btn theme-btn--yellow" data-theme=yellow type=button>Yellow</button><button class="theme-btn theme-btn--green" data-theme=green type=button>Green</button><button class="theme-btn theme-btn--blue" data-theme=blue type=button>Blue</button><button class="theme-btn theme-btn--red" data-theme=red type=button>Red</button></div><a href=https://github.com/lukoktonos/lukoktonos.com>source</a></div></footer></main><script>(function(){var a=document.documentElement;var b=document.querySelectorAll(".theme-btn");if(!b.length)return;function c(g){if(g==="amber")return "yellow";return g}function d(){var g=new Date().getMonth();if(g===11||g===0||g===1)return "blue";if(g>=2&&g<=4)return "green";if(g>=5&&g<=7)return "yellow";return "red"}function e(g){g=c(g);a.setAttribute("data-theme",g);try{localStorage.setItem("terminal-theme",g)}catch(h){};b.forEach(function(h){var i=h.getAttribute("data-theme")===g;h.setAttribute("aria-pressed",i?"true":"false")})}var f=c(a.getAttribute("data-theme"))||d();e(f);b.forEach(function(g){g.addEventListener("click",function(){e(g.getAttribute("data-theme"))})})})()</script>